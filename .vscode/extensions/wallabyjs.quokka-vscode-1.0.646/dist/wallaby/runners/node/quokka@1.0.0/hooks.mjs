import{parse as parseUrl,format as formatUrl,fileURLToPath,pathToFileURL}from"url";import{isAbsolute,extname,join}from"path";async function getTracer(){const t=global.$_$tracer;if(t&&t._esm&&t._esm.quokkaSettings&&!t._esm.initialized)if(t._esm.tsNode)t._esm.initialized=!0;else{t._esm.initialized=!0;try{const e=t._esm.quokkaSettings;if(e.ts){let s=e.ts.tsNode.ignore||["(?:^|/)node_modules/"];s=Array.isArray(s)?s:[s],s.push(t._esm.serverPath);const r={compiler:process.env.TS_NODE_COMPILER,ignore:s,ignoreDiagnostics:(process.env.TS_NODE_IGNORE_DIAGNOSTICS||"").split(",").map((t=>parseInt(t,10))).filter((t=>t)),compilerOptions:{experimentalDecorators:!!e.ts?.compilerOptions?.experimentalDecorators}};e.nativeEsm&&(r.experimentalEsmLoader=!0,r.transpileOnly=!0),e.ts.swc&&(r.swc=!1,r.transpileOnly=!0,r.transpiler=[e.ts.swcTranspilerPath,{swc:e.ts.swcPath}]);const o=e.ts.tsNode.path,i=await import(pathToFileURL(join(e.ts.tsNode.path,"dist","index.js"))),a=i.register(r);if(e.nativeEsm){const e=await import("semver");if(t._esm.tsNode=a,e.gte(i.VERSION,"10.8.0")){const e=join(o,"/dist-raw/node-internal-modules-esm-resolve.js"),s=await import(pathToFileURL(e)),r=(await import(pathToFileURL(join(o,"/dist/file-extensions.js")))).getExtensions(a.config,a.options,a.ts.version);t._esm.tsNodeResolve=s.createResolve({extensions:r,preferTsExts:a.options.preferTsExts,tsNodeExperimentalSpecifierResolution:a.options.experimentalSpecifierResolution})}else{const e=join(o,"/dist-raw/node-esm-resolve-implementation.js"),s=await import(pathToFileURL(e)),r=i.getExtensions(a.config);r.preferTsExts=a.options.preferTsExts,t._esm.tsNodeResolve=s.createResolve(r)}}try{if(e.ts.tsconfigPaths&&e.nativeEsm)try{const s=await import(pathToFileURL(join(e.ts.tsconfigPaths.path,"lib","index.js")));if(e.ts.compilerOptions&&e.ts.compilerOptions.baseUrl&&e.ts.compilerOptions.paths)isAbsolute(e.ts.compilerOptions.baseUrl)?t._esm.tsConfigPathsMatchPath=s.createMatchPath(e.ts.compilerOptions.baseUrl||e.ts.compilerOptions.pathsBasePath,e.ts.compilerOptions.paths):t._esm.tsConfigPathsMatchPath=s.createMatchPath(e.ts.compilerOptions.pathsBasePath||e.ts.compilerOptions.baseUrl,e.ts.compilerOptions.paths);else{const{absoluteBaseUrl:e,paths:r}=s.loadConfig();t._esm.tsConfigPathsMatchPath=s.createMatchPath(e,r)}}catch(t){}}catch(t){}}}catch(t){}}return t}export async function getSource(t,e,s){const r=await getTracer();if(r&&r._esm){const e=r._esm;if(t===e.scratchFileUrl)return{source:e.scratchFileContent}}return s(t,e,s)}export async function resolve(t,e,s){const r=await getTracer();if(r&&r._esm){const o=r._esm,i=o.scratchFileUrl;if(t===i)return{url:i,shortCircuit:!0};if(t.startsWith("file:")||t.startsWith("data:")||t.startsWith(".")){if(t.startsWith(".")||t.startsWith("file:")){const i=e.parentURL.split("?session=")[1]||global.$_$session;if(i!==global.$_$session)throw new Error("Session Error");const a=`?session=${i}`;let n,l=`${t=t.split(a)[0]}${a}`;const c=o.tsNodeResolve;try{n=c?await c.defaultResolve(l,e,s):await s(l,e,s)}catch(r){if(!c||[".js",".ts",".jsx",".tsx"].some((e=>t.endsWith(e))))throw r;{const o=[".ts",".tsx",".jsx"];o.push(...o.map((t=>`/index${t}`)));let i=!1;for(const r of o)try{l=`${t}${r}${a}`,n=await c.defaultResolve(l,e,s),i=!0;break}catch(t){}if(!i)throw r}}return r._doWhenReceiverIsReady((()=>{r._send("module",{path:fileURLToPath(n.url)})})),{...n,shortCircuit:!0}}}else{const r=o.localProjectDirUrl;if(e.parentURL.startsWith(r)){const i=e.parentURL;try{return await s(t,e,s)}catch(a){if("ERR_MODULE_NOT_FOUND"!==a.code)throw a;try{return e.parentURL=i.replace(r,o.tempDirUrl),await s(t,e,s)}catch(a){if("ERR_MODULE_NOT_FOUND"!==a.code)throw a;try{return e.parentURL=i.replace(r,o.settingsDirUrl),await s(t,e,s)}catch(r){if("ERR_MODULE_NOT_FOUND"!==r.code||!o.tsNodeResolve)throw r;{let a;e.parentURL=i;try{a=o.tsNodeResolve.defaultResolve(t,e,s).url}catch(t){}const n=async r=>{if("ERR_MODULE_NOT_FOUND"===r.code){if(t.endsWith(".js"))return resolve(t.substring(0,t.length-3),e,s);if(o.tsConfigPathsMatchPath){const i=o.tsConfigPathsMatchPath(t);if(i)return resolve(pathToFileURL(i).href,e,s);throw r}throw r}throw r};if(!a)return n(r);try{return resolve(a,e,s)}catch(t){return n(t)}}}}}}}}return s(t,e,s)}export async function getFormat(t,e,s){const r=await getTracer();if(r&&r._esm){const o=r._esm;if(t===o.scratchFileUrl)return{format:"module"};const i=o.tsNode;if(i){const r=parseUrl(t);if((null===r.protocol||"file:"===r.protocol)&&!r.hostname){const r=fileURLToPath(t.split("?")[0]),o=extname(r);let a;if(".mjs"===o)return{format:"module"};if(a=".js"===o||i.ignored(r)?await s(t,e,s):await s(formatUrl(pathToFileURL(r+".js")),e,s),!i.ignored(r)&&("commonjs"===a.format||"module"===a.format)){const{moduleType:t}=(i.moduleTypeClassifier.classifyModule||i.moduleTypeClassifier.classifyModuleByModuleTypeOverrides)(r.replace(/\\/g,"/"));if("cjs"===t)return{format:"commonjs"};if("esm"===t)return{format:"module"}}return a}}}return s(t,e,s)}export async function transformSource(t,e,s){const r=await getTracer();if(r&&r._esm){const s=r._esm;if(e.url===s.scratchFileUrl)return{source:t};const o=s.tsNode;if(o)try{t="string"==typeof t?t:t.toString("utf8");const s=parseUrl(e.url);if(null===s.protocol||"file:"===s.protocol){const s=fileURLToPath(e.url);if(!o.ignored(s))return{source:o.compile(t,s)}}}catch(t){return{source:`throw new Error(${JSON.stringify(t.toString())}); export default {}`}}}return s(t,e,s)}